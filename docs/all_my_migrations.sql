001_create_users_table.sql

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  spotify_id VARCHAR(255) NOT NULL UNIQUE,
  display_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE,
  profile_picture TEXT,
  refresh_token TEXT NOT NULL
);

002_create_curation_tables.sql

CREATE TABLE curation_requests (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  search_city VARCHAR(255) NOT NULL,
  search_date DATE NOT NULL,
  number_of_songs INT NOT NULL,
  playlist_id TEXT UNIQUE
);

CREATE TABLE curated_artists (
  id SERIAL PRIMARY KEY,
  curation_request_id INT REFERENCES curation_requests(id),
  artist_name_raw VARCHAR(255) NOT NULL,
  spotify_artist_id TEXT,
  confidence_score DECIMAL(5, 2)
);

003_alter_users_email.sql

-- Up
-- Allow the email column to be empty (null)
ALTER TABLE users ALTER COLUMN email DROP NOT NULL;

-- Remove the unique constraint (a null value can't be unique)
-- The name 'users_email_key' is the default one PostgreSQL creates.
ALTER TABLE users DROP CONSTRAINT users_email_key;

004_cleanup_public_curator.sql

-- This migration refactors the schema for the "public curator" model.

-- 1. Drop the `users` table.
-- We use CASCADE, which is a "sledgehammer" that automatically
-- finds and drops any Foreign Key constraints that reference
-- this table (like the one on curation_requests.user_id).
DROP TABLE users CASCADE;

-- 2. Drop the `user_id` column from curation_requests.
-- The CASCADE above only dropped the *constraint*, not the
-- column itself. We drop it now as it's no longer needed.
ALTER TABLE curation_requests DROP COLUMN user_id;

005_create_cities_table.sql

-- Up
CREATE TABLE cities (
  id SERIAL PRIMARY KEY,

  -- This will be the search query, e.g., "Austin, TX"
  -- We add UNIQUE to ensure we only cache each city once.
  name VARCHAR(255) NOT NULL UNIQUE,

  -- We use DECIMAL for high-precision coordinates.
  latitude DECIMAL(9, 6) NOT NULL,
  longitude DECIMAL(9, 6) NOT NULL,

  -- This is just good practice to see when a city was added.
  created_at TIMESTAMPTZ DEFAULT NOW()
);

006_alter_cities_for_autocomplete.sql

-- Up
-- This migration upgrades the 'cities' table for fast, case-insensitive searching.

-- 1. Add the new 'city_normalized' column
ALTER TABLE cities
ADD COLUMN city_normalized VARCHAR(255);

-- 2. Add the 'city', 'admin_name', and 'country' columns
--    that our seed script will populate.
ALTER TABLE cities
ADD COLUMN city VARCHAR(255),
ADD COLUMN admin_name VARCHAR(255),
ADD COLUMN country VARCHAR(255);

-- 3. let's make sure the column is required.
ALTER TABLE cities
ALTER COLUMN city_normalized SET NOT NULL;

-- 4. Drop the old 'UNIQUE' constraint on 'name'
ALTER TABLE cities
DROP CONSTRAINT cities_name_key;

-- 5. Create the new, fast index on our normalized column
CREATE INDEX idx_cities_name_normalized ON cities (city_normalized);

007_add_trigram_support.sql

-- Up

-- 1. "Install" the trigram extension in our database.
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 2. Abandon our "dumb" normalized column.
DROP INDEX IF EXISTS idx_cities_name_normalized;
ALTER TABLE cities DROP COLUMN IF EXISTS city_normalized;

-- 3. Drop the UNIQUE constraint on 'name'
ALTER TABLE cities DROP CONSTRAINT IF EXISTS cities_name_key;

-- 4. Create a new, *fuzzy-search* index on the *full name* column (e.g., "Austin, Texas").
CREATE INDEX idx_cities_name_trgm ON cities USING gin (name gin_trgm_ops);

008_add_unique_constraint_to_city_name.sql

-- Up

-- We are re-adding the UNIQUE constraint to the 'name' column.
-- This is necessary for our seed script's "ON CONFLICT DO NOTHING"
-- to work correctly, preventing duplicate city entries.
ALTER TABLE cities
ADD CONSTRAINT cities_name_unique UNIQUE (name);

009_remove_unique_constraint_to_city_name.sql

-- Up
    -- This migration UNDOES the '008' migration, which was based on a
    -- faulty diagnosis of the seed script bug.
    -- We are removing the UNIQUE constraint on 'name' to allow for
    -- potential duplicates in the seed data (e.g., two "Springfield, England" entries).
    ALTER TABLE cities
    DROP CONSTRAINT IF EXISTS cities_name_unique;

010_re_add_unique_constraint_to_cities.sql

ALTER TABLE cities
ADD CONSTRAINT cities_name_unique UNIQUE (name);

011_create_playlist_jobs_table.sql

CREATE TABLE public.playlist_jobs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- 'pending', 'building', 'complete', 'failed'
  status TEXT DEFAULT 'pending' NOT NULL,
  
  -- Job Inputs
  search_city TEXT NOT NULL,
  search_date DATE NOT NULL,
  latitude NUMERIC(9, 6) NOT NULL,
  longitude NUMERIC(9, 6) NOT NULL,
  number_of_songs INTEGER DEFAULT 2 NOT NULL,
  
  -- Job Outputs
  playlist_id TEXT,
  error_message TEXT
);

-- This function automatically updates the 'updated_at' column
CREATE OR REPLACE FUNCTION handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- This trigger applies the function to our new table
CREATE TRIGGER on_job_update
  BEFORE UPDATE ON public.playlist_jobs
  FOR EACH ROW
  EXECUTE PROCEDURE handle_updated_at();

012_add_index_to_jobs_table.sql

CREATE INDEX idx_jobs_status_created_at ON public.playlist_jobs (status, created_at);

013_drop_old_curation_tables.sql

DROP TABLE public.curated_artists;
DROP TABLE public.curation_requests;

014_add_genre_to_jobs.sql

ALTER TABLE public.playlist_jobs
ADD COLUMN genre VARCHAR(255) NULL;

015_alter_jobs_genre_to_array.sql

-- 1. Drop the single-string column we just added
ALTER TABLE public.playlist_jobs
DROP COLUMN genre;

-- 2. Add a new column that can hold an ARRAY of strings
ALTER TABLE public.playlist_jobs
ADD COLUMN excluded_genres TEXT[] NULL;

016_install_postgis.sql

CREATE EXTENSION IF NOT EXISTS postgis;

017_add_geography_column.sql

ALTER TABLE public.cities
ADD COLUMN geography geography(Point, 4326);

018_add_gist_index_to_geography.sql

CREATE INDEX idx_cities_geography ON public.cities USING GIST (geography);

019_add_population_to_cities.sql

-- Purpose: Adds the 'population' column to the cities table and creates an index 
-- to improve search ranking performance.
ALTER TABLE public.cities
ADD COLUMN population integer;

-- Creating a B-tree index on the population column, sorted descending (DESC),
-- to determine rank (i.e., largest population first).
CREATE INDEX idx_cities_population_desc ON public.cities (population DESC);

020_add_logging_columns_to_playlist_jobs.sql

-- Purpose: Adds columns to the playlist_jobs table to support the Live Activity Feed.
-- 'log_history' will store an ordered array of status messages (e.g. "Scanning...", "Found artist X").
-- 'total_artists' and 'processed_artists' are used to calculate the progress bar percentage.

ALTER TABLE public.playlist_jobs
ADD COLUMN log_history text[] DEFAULT '{}',
ADD COLUMN total_artists integer DEFAULT 0,
ADD COLUMN processed_artists integer DEFAULT 0;

021_add_events_data_to_playlist_jobs.sql

-- Purpose: Adds 'events_data' column to playlist_jobs to store rich event details 
-- (venue, ticket links, date, image) for the Concert List UI.
-- Using JSONB allows us to store the array of event objects flexibly without a new table.

ALTER TABLE public.playlist_jobs
ADD COLUMN events_data JSONB DEFAULT '[]';

022_add_min_start_time.sql

-- Up
ALTER TABLE playlist_jobs 
ADD COLUMN min_start_time integer DEFAULT 0;

023_add_max_start_time.sql

-- Up
ALTER TABLE playlist_jobs 
ADD COLUMN max_start_time integer DEFAULT 24;

024_add_owner_id_to_jobs.sql

-- Purpose: Add an owner_id column to link playlists to Supabase users (anon or auth).
-- We allow NULL values so existing historical jobs don't cause the migration to fail.

ALTER TABLE public.playlist_jobs
ADD COLUMN owner_id UUID REFERENCES auth.users(id);

-- Create an index on this column so fetching "My Playlists" is fast later.
CREATE INDEX idx_playlist_jobs_owner_id ON public.playlist_jobs(owner_id);

025_create_saved_playlists.sql

-- Purpose: Create a permanent table for user-saved playlists.
-- This decouples the "User Library" from the ephemeral "Job History".

CREATE TABLE saved_playlists (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- The User who owns this playlist (Cascade delete if user deletes account)
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Reference to the original job (Optional, for debugging lineage)
  original_job_id BIGINT REFERENCES playlist_jobs(id) ON DELETE SET NULL,
  
  -- Core Metadata
  spotify_playlist_id TEXT NOT NULL,
  name TEXT NOT NULL,       -- e.g. "Austin 12-31-2025 live music"
  city_name TEXT NOT NULL,  -- e.g. "Austin, TX"
  playlist_date DATE NOT NULL,
  
  -- We store the exact event data visible at the time of creation.
  events_snapshot JSONB DEFAULT '[]' NOT NULL,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for fast retrieval of "My Playlists"
CREATE INDEX idx_saved_playlists_user ON saved_playlists(user_id);

026_prevent_duplicate_saves.sql

-- Add a unique constraint
-- This ensures the database will throw an error if we try to save the same job twice.
ALTER TABLE saved_playlists
ADD CONSTRAINT unique_user_job UNIQUE (user_id, original_job_id);

027_add_filters_to_saved_playlists.sql

ALTER TABLE saved_playlists
ADD COLUMN min_start_time INTEGER DEFAULT 0,
ADD COLUMN max_start_time INTEGER DEFAULT 24,
ADD COLUMN excluded_genres TEXT[] DEFAULT NULL;

028_add_coords_to_saved_playlists.sql

ALTER TABLE saved_playlists
ADD COLUMN latitude DECIMAL(9, 6),
ADD COLUMN longitude DECIMAL(9, 6);

029_add_updated_at_to_saved.sql

ALTER TABLE saved_playlists
ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW();